import './ExpensesList.css'
import ExpenseItem from '../ExpenseItem'

const ExpensesList = (props) => {

    if (props.data.length === 0) {
        return <h1 className='expenses-list__fallback'>No expenses found for this year!</h1>
    }
    // якщо відфільтрований массив елементів буде дорівнювати 0 (в ньому не буде елементів), то відрендериться тег h1 (той що написаний рядком вище)

    return (
        <ul className='expenses-list'>
            {props.data.map(item => (<ExpenseItem key={item.id} data={item} />))} {/*ExpenseItem відіграє роль <li></li>*/}
        </ul>
        // {/* передані дані props.data мапуються на список ExpenseItems, яким передються дані за допомогою параметру item (item на даний момент це як props.data[], при кожній ітерації item буде змінюватись, наприклад (props.data[0], props.data[1]...) таким чином передаючи для кожного наступного ExpensItem дані відповідні актуальному tem ([0], [1]) до того моменту, коли не залишиться більше item в массиві) */ }

        // {/* KEY!!!!!!!!!!!!!!!!!!!!
        // Також при рендері списків кожному елементу списку треба додавати унікальний ідентифікатор key, тому що react при рендері кожного елементу не знає, що один елемент списку відрізняється від іншого, він просто бачить список однакових елементів, які треба відрендерити. Наприклад, при появі нового елементу в массиві, який рендериться react він додасть цей новий елемент в кінець списку(це можна побачити в консолі, якщо слідкувати в момент додавання нового елементу), навіть якщо той новий елемент в дереві був доданий на початок списку(бо немає ідентифікатора - він бачить всі елементи, як однакові), а потім відрендерить в UI (бо сталася зміна useState) той же елемент, тільки вже на початку, бо в DOM дереві він на початку. Через це можуть з'являтись баги, якщо в якомусь елементі списку є компонент який прив'язаний до стану елементу того ж самого елементу(елемент змінить своє місце і тим самим змінить свій стан - посунеться в списку і внутрішній компонент теж зміниться через цю помилку) 

        //Щоб цього уникнути кожному елементу треба додавати унікальний ідентифікатор, який буде говорити react, що він не такий самий, як всі інші елементи списку. І в такому випадку ідентифіковані елементи списку будуть з'являтись відразу на потрібних місцях, не "переїжджаючи" нікуди при появі нових елементів. 

        //Key значенням може бути, як унікальний ID прописаний в об'єкті, так і інше значення яке є в тому ж самому об'єкті*/}

        // Також можна використати такий запис в jsx-коді. Якщо filteredItems.length буде дорівнювати 0, то після оператора І "&&" повернеться список елементів. Тобто якшо значення перед && буде true, то повернеться те що знаходиться після && тобто ExpenseItems які відповідають актуальним умовам (рік в фільтрі)
    )
}

export default ExpensesList